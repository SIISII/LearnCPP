#define  _CRT_SECURE_NO_WARNINGS

#include  <cstdio>
#include  <cstring>

// 1. Устанавливаем счётчик символов в нуль.
//
// 2. Если текущий символ отличен от нулевого символа ('\0'), то:
//
//    - увеличиваем счётчик символов;
//    - переходим к следующему символу строки;
//    - повторяем п. 2.
//
//    Если же текущий символ является нулевым, возвращаем значение счётчика.

int  Str_Len(const char  *S)
{
    int  Length = 0;

    while ( *S != '\0' )
    {
        ++Length;
        ++S;
    }

    return Length;
}


// 1. Устанавливаем счётчик символов в нуль.
//
// 2. Если текущий символ отличен от нулевого символа ('\0'), то:
//
//    - увеличиваем счётчик символов;
//    - переходим к следующему символу строки;
//    - если счётчик символов достиг максимально допустимой длины строки,
//      прекращаем работу и возвращаем эту длину;
//    - повторяем п. 2.
//
//    Если же текущий символ является нулевым, возвращаем значение счётчика.

int  Str_Len_s(
    const char  *S,
    int          Len)
{
    int  Length = 0;

    while ( *S != '\0' )
    {
        ++Length;
        ++S;
        if ( Length == Len )
        {
            return Len;
        }
    }

    return Length;
}


// 1. Берётся текущий символ из исходной строки.
// 2. Взятый символ записывается в строку-результат.
// 3. Продвигаемся к следующему символу исходной строки.
// 4. Продвигаемся к следующему символу результата.
// 5. Если только что скопированный символ отличен от нулевого, т.е.
//    если исходная строка ещё не закончилась, п. 1-5 повторяются.

void  Str_Cpy(
    char        *Dst,
    const char  *Src)
{
    char  C;

    do
    {
        C = *Src;
        *Dst = C;
        ++Src;
        ++Dst;
    }
    while ( C != '\0' );
}


// 1. Обнуляем счётчик скопированных символов.
// 2. Берём очередной символ исходной строки.
// 3. Записываем этот символ в приёмник.
// 4. Продвигаемся к следующему символу исходной строки.
// 5. Продвигаемся к следующему символу приёмника.
// 6. Увеличиваем счётчик скопированных символов.
// 7. Если счётчик достиг предельного значения и 
//    скопированный символ не является нулевым символом,
//    возвращаем false.
// 8. Если счётчик предела не достиг и символ не является
//    нулевым, повтоярем п. 1-8.
// 9. Когда обнаружен нулевой символ, возвращаем true.

bool  Str_Cpy_s(
    char        *Dst,
    int          Len,
    const char  *Src)
{
    char  C;
    int   Count = 0;

    do
    {
        C = *Src;
        *Dst = C;
        ++Src;
        ++Dst;
        ++Count;
        if ( Count == Len && C != '\0' )
        {
            return false;
        }
    }
    while ( C != '\0' );

    return true;
}


// 1. Необходимо найти конец строки Dst, т.е. положение
//    в ней нулевого символа. Для этого:
//
//    а) Берём текущий символ строки Dst.
//    б) Если этот символ является нулевым, завершаем
//       поиск.
//    в) Если же этот символ не является нулевым,
//       продвигаемся в строке Dst к следующему символу
//       и повторяем п. а-в.
//
// 2. Копирование строки Src в конец строки Dst:
//
//    а) Берём очередной символ строки Src.
//    б) Записываем этот символ в текущую позицию Dst.
//    в) Продвигаемся к следующему символу Src.
//    г) Продвигаемся к следующему символу Dst.
//    е) Если скопированный символ отличается от нулевого,
//       повторяем п. а-е.

void  Str_Cat(
    char        *Dst,
    const char  *Src)
{
    while ( *Dst != '\0' )
    {
        ++Dst;
    }

    char  C;

    do
    {
        C = *Src;
        *Dst = C;
        ++Src;
        ++Dst;
    }
    while ( C != '\0' );
}


bool  Str_Cat_s(
    char        *Dst,
    int          Len_Dst,
    const char  *Src,
    int          Len_Src)
{
    int  Count_Dst = 0;
    int  Count_Src = 0;

    while ( *Dst != '\0' && Count_Dst < Len_Dst )
    {
        ++Dst;
        ++Count_Dst;
    }

    if ( Count_Dst == Len_Dst )
    {
        return false;
    }

    do
    {
        *Dst++ = *Src;
        ++Count_Dst;
        ++Count_Src;
    }
    while ( *Src++ != '\0' && Count_Dst < Len_Dst && Count_Src < Len_Src );

    return Count_Dst < Len_Dst && Count_Src < Len_Src;
}


// 1. Обнулить счетчик скопированных символов
// 2.берется текущий символ из исходной строки
// 3.взятый символ записывается в строку-результат
// 4.увеличить счётчик
// 5.продвигаемся к следующему символу исходной строки
// 6.продвигаемся к следующему символу результата
// 7.сравнить счётчик с требуемым числом копируемых символов
// 8.если счётчик меньше требуемого числа копируемых символов, то повторяем действия

void  Mem_Cpy(
    char        *Dst,
    const char  *Src,
    int          Len)
{
    while ( Len > 0 )
    {
        *Dst++ = *Src++;
        --Len;
    }
}


void  Mem_Move(
    char        *Dst,
    const char  *Src,
    int          Count)
{
    if ( Dst > Src )
    {
        Dst = Dst + Count;
        Src = Src + Count;
        while ( Count > 0 )
        {
            *--Dst = *--Src;
            --Count;
        }
    }
    else
    {
        while ( Count > 0 )
        {
            *Dst++ = *Src++;
            --Count;
        }
    }
}


int  main()
{
    char  S[50];
    char  S2[] = "DEF";

    printf_s("Enter string: ");
    scanf_s("%s", S, sizeof(S));

    Str_Cat(S, S2);

    printf_s("S + S2: %s", S);
}
